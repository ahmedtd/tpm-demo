syntax = "proto3";

option go_package = "github.com/ahmedtd/tpm-demo/lib/tpmcapb";

import "google/protobuf/timestamp.proto";

service CertificateAuthority {
    rpc ExchangeEKForCert(ExchangeEKForCertRequest) returns (ExchangeEKForCertResponse) {}
}

enum TPMVersion {
    V1_2 = 0;
    V2_0 = 1;
}

message ExchangeEKForCertRequest {
    TPMVersion tpm_version = 1;
    bytes endorsement_public_key = 2;
    bytes attestation_public_key = 3;
    bytes attestation_key_create_data = 4;
    bytes attestation_key_create_attestation = 5;
    bytes attestation_key_create_signature = 6;
}

// See "Trusted Platform Module 2.0 Library Part 1: Architecture" section 22.
message ExchangeEKForCertResponse {
    // A TPM credential that allows the EK to decrypt the challenge.
    bytes credential = 1;

    // Note, this multi-step wrapping is non-optimal.  If we read through
    // section 22, we are currently interpreting the word "challenge" literally

    // A challenge that can be decrypted by the EK.
    //
    // Once decrypted, this field contains a 32-byte AES-256 key that can be
    // used to unseal the sealed_certificate field.
    //
    // Note: The "challenge" terminology comes from the TPM spec, and I
    // personally find it somewhat confusing.  It can be any value, and does not
    // need to be returned to the server.  In theory, we do not need the
    // two-step wrapping with the "sealed_certificate" field, and we could
    // instead cram the sealed_certificate info into the challenge field.
    //
    // I think it may be better to maintain the two-step wrapping, though, since
    // I think the whole "challenge" field needs to be streamed through the TPM.
    // It's probably better to decrypt the large message on the CPU.
    bytes challenge = 2;

    // A SealedCertificate message, serialized and sealed using an AES-256 GCM
    // AEAD.  The key is the unencrypted contents of the "challenge" field.
    bytes sealed_certificate = 3;

    // The AES-256 GCM AEAD nonce for the sealed_certificate field.
    bytes sealed_certificate_nonce = 4;
}

message SealedCertificate {
    // A certificate issued to the attestation key, that can be used to
    // authenticate to relying parties.
    //
    // Serialized to DER, no PEM wrapping.
    repeated bytes certificate_chain = 1;

    // When should the client begin refreshing their certificate?
    google.protobuf.Timestamp begin_refresh_at = 2;
}
